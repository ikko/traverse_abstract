<html><head><link rel="stylesheet" href="style.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.1/js/bootstrap.min.js" integrity="sha512-EKWWs1ZcA2ZY9lbLISPz8aGR2+L7JVYqBAYTq5AXgBkSjRSuQEGqWx8R1zAX16KdXPaCjOCaKE8MCpU0wcHlHA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script></head>
<h1>abstract</h1>
<h3>Finding Balance-Fair Short Paths in Graphs</h3>
<h3>Finding Balance-Fair Short Paths in Graphs</h3>
<img src="abstract.png">
<p class="text"> Researchers from Berlin's Technische Universit¨at Berlin study the computational complexity of “balance-fair” short “paths,” they say. They say the difficulty of finding balance-fair short paths in graph-colored graphs has been a subject of broad and intensive study. Findings are published in ArXiv:2203.17132v1 [cs.DS] 31 Mar 2022; they prove the introduced problems to be computationally hard (NP-hard and parameterized hard with respect to the number of colors) </p>
<img src="abstract.png">
<p class="text"> They introduce and study a natural fairness scenario for one of the back-bone problems in network algorithmics: ﬁnding short paths. They prove that δ-Fair Short Path is para-NP-hard for the parameter number of colors in the input graph. They also prove that there is little hope for signiﬁcantly improving the latter result by showing Whardness. In this way, they also openthe ﬂoor for several future extensions and variants. </p>
<p class="text"> In this section, they study the computational complexity of the two problems parameterized by the number of colors. First, they look at the more general δ-Fair Short Path. They reduce from the well-known NP-hard problem Hamilton Path. The reduction does not work for the special case of a path that takes detours. They show that the reduction in this case is not the same as the reduction from the Hamilton Path problem. They also show that when there are two colors, the problem becomes NP hard, as seen by a polynomial-time reduction.<br/> They devise a dynamic program with a table T : T : V × [−n, n]c−1 → {0, 1} storing whether there is a shortest s-v-path. The program is solvable in O (2n)c− 1 · m) time. They use the table T: V × (V) × [+n]c+1) to find out if the path is shortest. They also use a table to test whether </p>
<p class="text"> The diﬀerence between the number of vertices of colors c and i is exactly xi. in G. They say that such paths respect the tuples (x1, x2, xc−1) in order of their distances from s. In G, they distinguish whether the color i of v is c or not. If i < c, then they iterate over all incoming arcs (u, v) and compute T[v] =. (u) and v (v) is set to true if v has a neighbor u for which T[u] is true)<br/> If such an arc (u, v) exists, then there is a shortest s-u-path respecting (x1 +1, x2 + 1,..., xc−1 + 1). Appending v to this path results in a path that has one additional vertices of color c. If at least one such entry is true, there is no balance-fair short-uveest s-t-path in G. Conversely, if all these values are false, then if all the values in G are true. </p>
<p class="text"> There is little hope for a signiﬁcantly better algorithm for δ-Fair Shortest Path parameterized by the number c of colors. They reduce from Multicolored Clique by solution size k to a graph H with two vertices s and t that contains a balance-fair shortest s-t-path if and only if G contains a clique of size k. The graph H will be made mostly from two parts: a vertice-selection gadget for each partition Vi and an edge-veri-veriumgadget for each pair Vi ̸= Vi′ of partitions. </p>
<p class="text"> Each path represents a vertice in V1 and the respective vertices are listed above each path. This encoding is used within the edge-veriﬁcation gadgets. For each partition Vi, Vi′ of partitions is again a collection of vertex-disjoint parallel paths whose endpoints are adjacent to two vertices of color q. The number of vertices in all levels combined is (k − 1)2 · (k + 1), (k) + (k1) </p>
<p class="text"> The number of vertices that are not of color q in each shortest path through all the diﬁcation gadgets is exactly the same as the vertices of each color q. In order for such a path to contain the same amount of the k2 colors from q have to appear (k − 1) The reduction runs in polynomial time as the base-k representation of a number can be computed in a number. The construction remains to show that the constructed instance is a yes-instance. For the forwardc-c-reaction, suppose that G contains a clique K on |K| = k. </p>
<p class="text"> Consider the path P from s to t that contains all vertices of color q. They claim that P contains exactly (k − 1) · kℓ−1 (k-1) · �βreferior) The resulting instance of the δ-Fair-Fair.-Shortest Path is a yes-instance. The claim holds that the claim holds (k) that the paths representing edges in K′ are a (multicolored) clique, concluding the claim implies that K is a multicolored clique.<br/> There are subpaths of P through edge-veriﬁcation gadgets that encode edges with an endpoint in Vi other than vi-j′. The target number for each color is (k −1)·�ℓ−1) and each gadget contains each color a multiple of k times, it follows that the number of vertices of color riophobicd in P holds for all gadgets. Assume the claim that the claim does not hold, that is that the claims do not hold. </p>
<p class="text"> The algorithm works in two steps. They guess how many vertices of each color are contained in a solution. They then check whether there is an s-t-path that contains each of these labels exactly once. They devise a dynamic-programming table T : V × 2[c] × {0, 1,... ℓ+2·ℓO(log ℳ) time. They name this problem Exact Colored Path. The algorithm as--insuredsigns ki distinct labels to each color and then checks whether such a path exists.<br/> If there is an s-v-path of length ℓ using all colors in S ⊆ [c] exactly once, then there has to be a neighbor u of v. Otherwise, they have T[v, S, d] =.˚��u∈N(v) and T[u, S \ {χ(v), d − w({u, v}]]].˚u has a colorful s-t </p>
<p class="text"> The color-coding algorithm for Exact Colored Path uses perfect-hash families to derandomize this technique in most applications. They create an (n, k)-perfect hash family F of functions [n] → [k] in ekkO(log k)n log n time using Lemma 6. For each remaining function f ∈ F, they check whether G contains an s-t-path P of length at most ℓ that is colorful with respect to f.<br/> For each i, the number ki = |χiP| of vertices of color i such that q ≤ ki ≤ q + δ and k = 1 ki = k. Then, they use Lemma 7 to check if there is an s-t-path of length at most ℓ containing exactly ki vertices. Since they brute-force all possible assign-ments for ki, the algorithm is correct if c ≤ k. The algorithm is right if </p>
