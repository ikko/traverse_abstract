<html><head><link rel="stylesheet" href="style.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.1/js/bootstrap.min.js" integrity="sha512-EKWWs1ZcA2ZY9lbLISPz8aGR2+L7JVYqBAYTq5AXgBkSjRSuQEGqWx8R1zAX16KdXPaCjOCaKE8MCpU0wcHlHA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script></head>
<h1>abstract</h1>
<h3>Disentangling the Computational Complexity of Network Untangling</h3>
<h3>Disentangling the Computational Complexity of Network Untangling</h3>
<img src="abstract.png">
<p class="text"> The classical Vertex Cover problem is among the most well-studied NP-hard problems in the context of parameterized algorithmics. Real-world graphs, however, are often dynamic and change over time. In modern applications, this temporal information is readily available and allows for more realistic models. This problem has data mining applications that explain the interactions of interactions of interacting networks in complex networks. The paper was published at the DFG Research Training Group 2434 “Facets of Complexity” </p>
<img src="abstract.png">
<p class="text"> Several classical graph problems have been studied on temporal graphs. In this paper, they study the network untangling problem introduced by Rozenshtein et.al. This is a temporal variant of Vertex Cover and motivated by data mining. The task is to find a k-activity timeline that minimizes some objective regarding the interval lengths. An example instance and solutions for each of these two problems are pictured in Figure 1. </p>
<p class="text"> Theorem: MinTimeline∞ parameterized by n is W-hard even for ℓ = 1 (Theorem 12), while MinTimelines+ is in FPT (Theorems 9 and 7) Theorems 6 and 7 show that both problems are in XP when parameters are parametired by n. They also show that MinTimline∞ is hard even for n + k (Theory 5) for the case k = 1, they strengthen the NP-hardness of minTimeline+ showing it already holds for two layers. </p>
<p class="text"> A (k:1)-coloring of a graph is simply a k-coloring. For a graph G = (V, E) and a, b ∉, a (a:b)-Coloring) of G is a function c: V →�[a]V," a (k-b)coloring, such that c(u)∉c(v) = ∅ for all {u, v} ∈ E. Theorem: MinTimeline∞ (MinTimeline+) is NP-hard, even if k = 2, ℓ = 0, and all layers are identical. </p>
<p class="text"> They show NP-hardness with a reduction from Odd Cycle Transversal. The input consists of a graph G = (V, E) and an integer s and the task is to decide whether it can be satisﬁable by deleting at most s clauses. They show that MinTimeline∞ is polynomial-time solvable for k = 1. By contrast, MinTimelines+ with two layers is NP hard and FPT for parameter ℓ. The problem is known to be in FPT when parameterized by s.<br/> T := {(v, 1, 2) | (¬xv.), (xv,) = true) T is a 1-activity timeline that covers G with (v,a,b)∈T (b − a) ≤ ℓ. Conversely, if T covers G, G is a timeline with a single clause, T can be a timeline that is NP-hard. The interesting parameterizations remaining involve the number n of vertices. If MinTimeline∞ and MinTimelines+ are NP hard, the interesting parameters involve n and τ, as the n number n is bounded in these two parameters. </p>
<p class="text"> Theorem: MinTimeline∞ is solvable in (k + 1)n(ℓ + 2)n2nτnO(1) time. They solve an instance (G = (V = {v1,... vn}, (Ei)i∈[τ), k, k, ℓ) via dynamic programming. They deﬁne a Boolean table T of size τ(k+1)n (T)n = T, T[i, k1, kn] = true if and only if there exists a T (V) × [i] with max(v,a,b)<br/> An entry of the table can be done with at most 2n table look-ups. MinTimeline+ is solvable in (k + 1)n2O(n)τ(ℓ) time. For each i, k1, kn, l, vn, k, ki, kn and l, l] = true if and only if there exists a T ⊆ V × [i] + [i], vn and l that covers (V, E1,... vn), vn; vn: true if (v,a,b)∉T (b), vx; vx) is true </p>
<p class="text"> A table entry can be computed with at most 4n table look-ups leading to an all-time running time of τ(ℓ + 1)(k + 1)n2O(n) Theorem 8: MinTimeline∞ is solvable in O(2nkn2T) time. They solve the instance with a search tree algorithm similar to the one for the classical Vertex Cover. They store counters kv, v. v, v. and v. for the number of intervals chosen for each edge. If ku = kv and kv kv cannot cover an arbitrary edge, then they return “no”<br/> The recursion terminates after at most nk calls. In each branch, they increase the corresponding counter (ku or kv) by one, delete all edges incident to the corresponding vertices (u or v) from the layers Ei,... Ei′ = min(i + ℓ, τ) The running time is in O(2nkn2τ), and the recursion ends after at least one call or two branches. Thus, the </p>
<p class="text"> A k-activity timeline T for a temporal graph G with n vertices is of size at most kn, they show that MinTimeline∞ and MinTimelines+ are in FFPT when parameterized by the solution size |T |. The formal proof is deferred to the end of this section. They use a variable XS.E for every E for every V, V, E, V and V. The number of possible induced interval graphs is upper-bounded by a function only depending on n + ℓ. They observethat T>0 induces an interval graph. </p>
<p class="text"> Theorem 9: MinTimeline+ parameterized by n+ℓ is in FPT. The algorithm in the following proof is illustrated in Figure 2. For an instance (G = (V, (V)i)i∈[τ), k, ℓ), they say that an ‘possible’-pattern is a solution T of I as follows: For any E, let C(E) =. Theorem 2 and Lemma 10 together imply the following.Corollary 11: Coloring by the number of vertices is in the FPT.<br/> The weight of a solution pattern (P, I) is w(P) := (P) = (v,a,b)∈I(b − a) The weight is w, which is the number of layers of G that is equal to P. Since I contains an interval with positive length, they can choose at most ℓ such solution patterns. Hence, they iterate over all functions f : P → {0,..., P, I, P, P: f: P: P; P: F: P f(x)w(x </p>
<p class="text"> Algorithmically, they simply determine is and js by ﬁnding the earliest occurrence of Ps in E1,.. The result is a sequence (P1, I1),..., (Pr, Ir) of r ≤ ℓ-resembled patterns. The arguments above imply that they check at most (ℓ+1)2O(n2) ·such-such-sequences. They then compute the remaining temporal graph obtained by implementing the solution-patterns (G′, (kv)v∉V) of Nonuniform MinTimeline+.<br/> The interval multiset I := {[a, b] ⊆ [τ] | (v, a, b) ∈ T>0) The corresponding interval graph GI := (I, EI) contains at most ℓ connected components. They will describe the solution pattern corresponding to each connected component of GI. For a connected component C of GI, let i := min [a,b]∈C a and j := max[a]∉C b. Note that j − i + 1 + 1 is a solution for (G, k) and (G) + (G), k, g, g) </p>
<p class="text"> Theorem 12: MinTimeline∞ parameterized by n is W-hard for ℓ = 1. The key diﬀerence to the case is that, for example, the temporal ordering of the layers is relevant. They prove that the resulting residual temporal graph G′ is the same as the residual. temporal graph derived from the connected components of GI up to a permutation of the. layers. They claim that the algorithm returns true for this particular sequence of solution pat-heticalterns. </p>
<p class="text"> An output instance for Unary Bin Packing is a yes-instance for Multicolored MinTimeline∞ (see Figure 3.) They construct an instance (G = (V = V1) for V1, V1 + v1, v1 + 1, vβ) for Mul--glyticticticolored Min Timeline. The output instance can be computed in polynomial time and |V | = 2β. The number of layers is τ := 2S. The ﬁrst 2s1 layers represent item 1, and 2s2 layers representing item 2, and so on. </p>
<p class="text"> T must contain all but one of these vertices in every layer representing an item. The number of intervals containing a vertice in Vβ+1 is at most β(S − B) = βS − S = S(β − 1) intervals. T contains intervals of the form (ub, t + a) where t is the ﬁrst layer corresponding to a particular item and a is even odd. For every item i ∈ [m] there exists exactly one j ∉ [β] such that (uj, t) is not in T for all 0 ≤ a ≤ si − 1. </p>
<p class="text"> The proof is by reduction from Multicolored MinTimeline∞. For every i and every v, they set k′ipientv := ki. In every layer ti, the vertices in Vi form a clique while all other vertices are isolated. For each v, let kv := |{(v, a, b) ∈ T | v, v | v | Vi | Vi, a |Vi | | Vi| − 1, v| | Vi: |f −1 (v) | Vi), |f + ki (v, v) | kv: kv; v: v; v, a; v; j: v.<br/> The layers of G′ are as follows: For t ∈ [τ], they simply construct an instance of MinTimeline. Then, they construct a k-activity timeline T ′ that covers G′ as follows. The layers only contain the edge {u1, u2}. Then, for i. i, the layers E′ are empty. The lay-out of T is an activity timeline that covers the G and contains only kv intervals that.use v for each v, V, V and kv. </p>
