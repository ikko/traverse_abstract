<html><head><link rel="stylesheet" href="style.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.1/js/bootstrap.min.js" integrity="sha512-EKWWs1ZcA2ZY9lbLISPz8aGR2+L7JVYqBAYTq5AXgBkSjRSuQEGqWx8R1zAX16KdXPaCjOCaKE8MCpU0wcHlHA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script></head>
<h1>abstract</h1>
<h3>Controlling Golog Programs against MTL Constraints</h3>
<h3>Controlling Golog Programs against MTL Constraints</h3>
<img src="abstract.png">
<p class="text"> Authors: Golog is an expressive programming language to describe high-level robot behavior, but it is often tedious to use on real-world robots. They propose to make these constraints explicit by modeling them as MTL formulas, which enforce the execution of certain low-level platform operations in ad-naissancedition to the main program. Instead of having a single detailed program, the developer needs to focus on the high level behavior while ensuring that all all the constraints are satisisﬁed.<br/> The situation calculus (McCarthy 1963; Reiter 2001) is a logical formalism for reasoning about dynamical do-mains based on ﬁrst-order logic. Golog (Levesque et al. 1997;.De Giacomo, Lesp´erance, and Levesque 2000) allows to control the high-level behavior of robots. The logic t-ESG extends Golog with clocks and clock constraints to express timing constraints. It is a theoretical framework for controller synthesis on GOLOG programs given an MTLspeciﬁcation. </p>
<img src="abstract.png">
<p class="text"> A timed automaton (TA) is an automaton equipped with a set of clocks, whose real-timed values progressivelyincrease uniformly. They build on top of this result to solve the synthesis problem of time-synthesis. Rather than constructing a TA, they synthesize a controller based on a symbolic execution of the program. They start by describing t-ESG, a logic that allows to use the speci-cation of GOLOG programs with timing constraints. In turn, ESG and ESG allow expressions that refer to time as referring to time directly to time, as this leads to undecidable.<br/> The language has three sorts: object, action, and clock. A special feature inherited from ES is the use of countably in nite sets of standard names for those sorts. Standard object and clock names syntactically look like constants, but are isomorphic with the set of all objects (clocks) of the domain. They only allow Comparisons to clock values as well as clock resets. They assume that object standard names include the rational numbers as a subsort. </p>
<p class="text"> Given a world w, a ﬁnite trace z, and a clock valuation ν, they deﬁne w |= α as w, ⟨⟩,⃗0, where a formula is the truth of a formula. In contrast to ESG, they are only in-terested in in te traces, as MTL is undecidable over in problemslike ESG (Ouaknine and Worrell 2005) They use the program transition semantics to denote only the timelines resulting in a program trace.<br/> A basic action theory (BAT) deﬁnes the preconditions and effects of all actions of the domain, as well as the initial state. They consider a system of a robot that can pick up (grasp) an object o, with the following pre-conditions:. The robot needs to grasp an object at a location and the object needs to be at that location. Grasping can only end when the robot is already grasping the object (nor holding)<br/> The effects of actions on ﬂuent predicates are purposefullyspeciﬁed by a post. The effects are detailed in the form of a free variable. The modality □ has lower syntactic precedence than the con-centricnectives, and [·] has the highest priority. Free variables are implicitly universal quanti﬉ed from the out-side. The effect of actions is detailed in Equation 3 to Equation 5, e.g., holding(o) or if the robot is currently holding o and does not start to grasp o. </p>
<p class="text"> The correct operation of the gripper requires a camera module to be operational before starting to grasp for an ob-ipientject. The low-level BAT speciﬁes the following effects of actions:. The initial situation, i.e. the initial satisfaction of the.uent predicates is described by:. (i.e, i = o if x is of sort object) and. again. They call a BAT a.ggie-nite-domain basic action theory (fd-BAT)<br/> They can now deﬁne an equivalence relation between two worlds, where two worlds are equivalent if they initially sat-isfy the same ﬂuents. For a fd-BAT, a world has ﬁnitely many equivalence classes: For each equivalence class, they only need to consider one world: Theorem 1. Let’s they assume in the following that for a given Σ, w, w′ be two worlds with w ≡Σ0 w′.<br/> Given a set P of atomicpropositions, the formulas of MTL are built as follows: P = p | p | ¬φ | φ ∧ φ | U grasping(o) says that the object o must be grasped in the interval and until then, the camera must be on the ground. They use abbreviations FIφ := (⊤ UI φ) (ﬁn </p>
<p class="text"> They use strict-until, i.e., they require that i < j rather than i ≤ j, to express a word that accepts a word ρ iff the word satisﬁes formula φ, i. They refer to Ouaknine and Worrell (2005) for the full construction of an ATA Aφ (ATA) The ATA has an implicit single clock x. A state of A is a pair (l, v), where l is the location and v is a clockvaluation of the clock x. They denote the set of all possible states with Q.<br/> The language accepted by an ATA is deﬁned in terms of a transition system TA = (2Q, ⇝, →) over sets of conשּׁ�g-urations. The time-labeled transition relation captures the progress of time in so-called ﬂowow steps. Given an MTL formula φ, the ATA Aφ with L(φ) = L(A), they can build a GOLOG program against an Mtl-speci-speculation such that all execution traces satisfy the speci-espci-speechci-<br/> Given a program A = AE ˙∪AC of possible actions and an MTL formula φ, a controller CR is a partial function that maps to a set of successor conﬁgurations. CR is non-blocking, i.e., it does not add a program deadlock, and only maps to valid successors (C1) CR(z, ν, δ) = {(zi, �i, �i)i∈I) is the small-walletest set such that (1) for each (a1, t1), (2), for each pre-Zi of z, (2) for </p>
<p class="text"> Given a world w and a BAT, the ﬂuent trace ψ(z) corresponding to a timed trace z is a fluent trace. The goal of this work is to synthesize a controller which synthesizes actions of a high-level program and a second, purposefully low-level programs in such a way that a task is successfully executed while complying with a given speciﬁcation. The approach consists of the following steps: (1) they de-privatlyconstruct an ATA Aφ from the speci-centriccation, (2) they use a labeled transition system E that symbolically exe-cutes the GOLOG program, (<br/> The symbolic execution of a program is a labeled transition system E = (E, e0, −→) deﬁned as follows: E = S∆ × NC × sub(δ) and e0 = (S) The E of the program E is (E) with the following transitions: (e0) with (start cam()()); (e) | start grasp()), (e1) and (e2) E = E; (e), e; e;e; e: E; e0;e: E.;e.y;e1;e2;e3;e4:e:e;e<br/> The following theorem establishes the validity of a symbolic execution with respect to explicit program traces. The product automaton of the symbolic execu-heticaltion E and the ATA Aφ is used to track the satisfaction of the satisfactionof the input speciﬁcation. Given a symbolic ex-rexecution E = (E, e0, −→) and an ATAA A φ, the synchronousproduct S = (S, s0, →) is a labeled state transition system. </p>
<p class="text"> The synchronous product S of E and A looks as follows: (e0, G0), (e, G) (e) G (G) is a set of regions deﬁned for each 0 ≤ i ≤ K as REGK (REGK) Regionalized clocks (tuples of name and region) used to represent a regionalized state as follows. They regionalize the states S of S to obtain a canon-centricrepresentation of a region in REGK. For each S-state, they compute its canonicalrepresentation.<br/> They say that two S-conﬁgurations S = (s, ν, ρ, G) and (S) are equivalent. The relation ∼ is a bisimulation over S, i.e., S1 ∼ S′and S1/S2 implies S′.-S′-S is a synchronous product S = S, s0, −→. The discrete quo-tient T∼ of S is a symbolic transition system (STS) with S∼ = S. The regionalization of S from Example 4 looks as follows: With a regionalized ver-sion of S, they can de-<br/> With the deﬁnition of T∼ they have obtained a product automaton of the input program and the speci-cation. However, the abstraction of TT∼ allows several successors for the same symbolic ac-utiction a. Theorem 7.2: z ∈ Z(T) iff z ∉ Z(S) or Z(Z(T), or z(Z) is true. The deterministic quotient DT ∼ = (SW, c0, C) or DT (D) is de-denialed as follows. </p>
<p class="text"> They construct a timed game over DT ∼, whose states allow to determine safety with respect to the speciﬁcation. A state in DT ∼ is bad, if it is ﬁnal and contains a bad-confection-convenient-enough state. They can design an algorithm that synthesizes a controller with a safe Golog program that leads to a safe state. The algorithm is designed to synthesize a controller, where a controller exists if there is a safe strategy, i.e.e., a trace in the GOLOG program leads to an accepting state.<br/> The underlying problem of ﬁnding a winning strategy in the game is decidable. They show that the search over states of DT ∼ terminates. The monotonic domination order (Λ∗, ⊆) is a wqo. They have synthesized the conﬁgura-gura of state of DT, C, C′, which is a prod-esian program of a symbolic trace of a program. They use results by (Abdulla and Nyl´en 2001) which relate the orderings to state that orderings are different.<br/> The Cartesian product of a ﬁ-nite number of wqos is a wqo. The ordering (SW, ≤d) between states of DT ∼ is deﬁned as follows: (s, ρ, C), (s′, C) ≤d, (2) ρ = ρ′, and (3) C ⊑ C′. The Golog controller synthesis problem for GOLOG controller synthesis problems is decidable. </p>
