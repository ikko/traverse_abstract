<html><head><link rel="stylesheet" href="style.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.1/js/bootstrap.min.js" integrity="sha512-EKWWs1ZcA2ZY9lbLISPz8aGR2+L7JVYqBAYTq5AXgBkSjRSuQEGqWx8R1zAX16KdXPaCjOCaKE8MCpU0wcHlHA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script></head>
<h1>abstract</h1>
<h3>Verifiable Quantum Advantage without Structure</h3>
<h3>Verifiable Quantum Advantage without Structure</h3>
<img src="abstract.png">
<p class="text"> There are NP search problems solvable by BQP machines but not BPP machines. There exist functions that are one-way, and even collision resistant, against classical ad-reversaries but are easily inverted quantumly. Similar separations hold for digital signatures and CPA-secure public key encryption. The results do not appear to contradict the Aaronson-Ambanis conjecture. By replacing the random oracle with a concrete cryptographic hash function such as SHA2, they obtain plausible Minicrypt instantiations of the above results. </p>
<img src="abstract.png">
<p class="text"> Contents of the book includes the introduction of a series of articles titled, "Psychiatrician" and "Physicianian" The book is written in "Psychicianthropicianicianisticianism" and a revised version of "Phsychianisticianism," "Psychianismicianist" is published in "Phiopsychianismanismanist" (2013) and "Phanistianistismanistician" (2014) The book has been published since 1998. </p>
<p class="text"> Aaronson and Ambanis give some evidence for Conjecture 1.1, by reducing it to a plausible mathe-centric conjecture. They say random oracles are equivalent to the non-relativizing world with respect to NP decision problems. But for any particular algorithm Q, proving computational ineﬃciency amounts to an unconditional hardness, which is beyond the reach of current complexity theory. Their results make progress toward justifying super-polynomial quantum advantage for NP problems under less structured oracles or milder computational assumptions. </p>
<p class="text"> Theorem: Relative to a random oracle, there exists a compressing function that is collision-resistant against any computationally unbounded uniform adversary making a polynomial number of classical queries, but is not even one-way against quantum adversaries. By adding a message from the veriﬁer to the prover, the protocols become public coin and publicly veri ﬁable. They also obtain an unconditional analogous separation for digital signatures and CPA-secure public key encryption. </p>
<p class="text"> Aaronson and Arkhipov [AA11] and Bremner, Jozsa, and Shepherd [BJS10] give a sampling task with such a speed-up based on plausible complexity-theoretic constructions. They also obtain candidate Minicrypt examples of NP search problems in BQP\BPP, functions that are classically one-way but quantumly easy, and even certiﬁable randomness. The work gives the ﬁrst evidence besides the period period of quantum advantage for this class. </p>
<p class="text"> Theorem: f O.C is unconditionally one-way against classical probabilistic algorithms making polynomially-multiple queries to O. They explain in Section 7.2 how to obtain the full Theorem 1.3. For each consistent codeword, the probability of being a pre-image of y is at most 2+n over the choice of random oracle. They show that the probability. of being. a pre image of y in this case is small, even for adaptively chosen queries.<br/> [HIOS15] construct a very similar hash function from list-recoverable codes. Their hash functions assume a multi-bit O, but then XORs the results together, rather than concatenating them. They prove that their hash function is collision-resistant. The novelty, and what does not appear to be possible for their construction, is the quantum pre-image ﬁnder, which we're going to discuss next. We're looking at quantum images, </p>
<p class="text"> The algorithm can be seen as loosely inspired by Regev’s quantum reduction reduction between SIS and LWE [Reg05] Given an image y, the goal will be to create a uniform superposition over pre-images of y:. The algorithm is loosely inspired. It constrains C to having a rate where they only know how to prove one-wayness. Proving Theorem 1.4 therefore requires a diﬀerent, which they elaborate on in Section 7.2.2. </p>
<p class="text"> They show that c is uniquely information-theoretically decodable (whp) provided the rate of C is not too high. In the case where C is a folded Reed-Solomon code, C⊥ is essentially another Reed-solomon code. They can decode eﬃciently using list-decoding algorithms [GS99]. They observe that |�τi,yi⟩ has roughly half of its weight on 0, whereas the remaining half the weight is essentially uniform (though with complex phases) since O is a random function.<br/> By using the fact that f O.C is one-way even against sub-exponential-query algorithms, they can show that the min-entropy must be polynomial. They can easily get uniform random bits by having the private random seed extracted using a private seed. The above results all considered sampling a random oracle, and then sampling the adversary. A standard complexity theory argument shows that, in the case of uniform adversaries, the order of quantiﬁ </p>
<p class="text"> This is a consequence of leveraging the “salting defeats preprocessing” result of [CGLQ20] to obtain polynomially-many random bits. For non-uniform adversaries, they have to work harder, and direct analogs of the results above may in fact be impossible. They showvia careful arguments how to overcome this limitation, obtaining two message proofs of randomness where the veriﬁer’s message remains small. The remainder of the paper is organized as follows as follows.<br/> The classical random oracle model is often just referred to as the ROM, but they call it CROM to emphasize that the oracle access is classical. In CROM, every party (including honest algorithms of algorithms) can classically access a random function H. They simply write |ψ⟩ ≈ |φ⟨ to mean | ω⟟ = C for some C. The model is based on the fact that H was chosen at the beginning, and every party can access H. </p>
<p class="text"> In other words, a quantumly-accessible classical oracle that applies a unitary|x⟩ |y ⊕ H(x) is available. See Section 3 for more detailed treatment of these models. They often consider vectors x ∈ Σn over the alphabet Σ = Fm. The trace function Tr : Fq → Fp is deﬁned by3.2.1.2: Tr(X) := (x) := (X) = (x1,.., xn) They denote by 0.0 to mean (0,...., 0) ∈ Fn (F) and (Fn) </p>
<p class="text"> For a function f : Σn → C, they deﬁne.f(z) :=apologeticˆf(x) =.glyglyglyf(f) Glyphianf(y) · g(f)(x) :=glyphiangigigigi(f (x)) Glastonishingly, this is proven by the fact that QFT is a unitary, which is shown in [dBCW02, [vDHI06] </p>
<p class="text"> They rely on the following form of Chernoﬀ bound. Let X1,.., Xn be independent random variables taking values in (X) and (Xn) Xn. For functions f : Σn → C, g : C, g: C, h: C; f: C: C : C; g: c: C = C; h: c; C: c : C, C: D: C. They say that for functions f and g: g, g, c: c, C; c: A: C | C; C;. C: P: C. | C. | C </p>
<p class="text"> A random oracle is the oracle associated with a random inﬁnite-length bit-string. They associate the set of oracles H : {0, 1}∗ → { 0, 1}. They provide several de�nitions in the Random Oracle Model. They consider three settings: Oracle-independent, uniform oracle-dependent, uniform-dependent and non-uniform. Uniform-dependent models capture the standard model as closely as possible, where H is replaced with a hash function. </p>
<p class="text"> For one-way functions, they only consider keyless functions, as it is well known that keyless and keyless ones are equivalent. They say that a family {fλ : {0, 1}ℓkey × rejectedagainst oracle-independent adversaries in the CROM (resp. QROM) if for all unbounded-time uniform adversaries A, there exists a negligible function negl such that inequality (7) holds. A (keyed non-interactive publicly veriﬁable) proof of quantumness in the QROMconsists of algorithms (Prove, verify) </p>
<p class="text"> A proof of quantumness is (Q(λ), ǫ(λ)-sound against oracle-independent adversaries. They now deﬁne proofs of (min-)entropy and proofs of randomness. These are protocols by which a classical veri�acher with very little entropy can produce signi ﬁcant entropy with the help of a potentially untrusted quantum device. They also note that derenewable randomness relative to a random oracle is subtle. This is because a malicious device may always always always have a deterministic value. </p>
<p class="text"> A keyless proof of min-entropy has ℓkey = 0, in which case all algorithms additionally take 1λ as input. A proof of randomness has the same syntax as a proof of quantumness, except that they require the output of the algorithm to be exactly h bits. They then upgrade the requirements to true randomness to the requirements of a keyless algorithm that takes a certain number of queries to the random oracle H. They now discuss relations of the relations between the various de-nitions above. For one-wayness, QROM security implies CROM security. </p>
<p class="text"> The ﬁrst theorem shows uniform security follows from oracle-independent security. In the non-uniform case, the above fails. This is because the advice for A is now an inﬁnite-length string a1, a2, and therefore the advice strings are uncountable. They next discuss how salting actually does lift security for proofs of min-entropy/randomness. They note that salting does not work, but actually lifts security for the random string. </p>
<p class="text"> Theorem: If (Prove0, verify0) has min-entropy (resp. true randomness) against oracle-independent adversaries in the QROM. ProveH( k0||k1, h ) = Prove H(k0/k1) and verifyH(k1/k0, h + 1, π) where k1 ∈ {0, 1}λ; k1 is k1, k0, k1; K1 is a random set of size ℓ, for an example of quantum query complexity argument.<br/> They will now use the following lemmas to argue that replacing H1 with H′ocre1 negligibly aﬀects the output distribution of A: Theorem 3.11 [BBBV97] Lemma 3.12: The output distribution is conditioned on the query amplitude being negligible. They conclude that A is a quantum query algorithm that makes T queries to an oracle O. They argue that H1 and O′ are identical to each other on all points not in S. </p>
<p class="text"> For a random S, k1, they can equivalently sample H′′β1 as follows: choose a random set of size ℓ, and then set k1 to be a random element of T and S = T \ {k1}. Then with overwhelming probability over the choice, the following holds: conditioned on an, the function H′β-β1 is statistically close to H′-ββ1 deﬁned.conditioned on an. Condition on an only reduces the average entropy (over s) of the H1(s, ·) by a negligible amount.<br/> If B were to choose S, k1 uniformly, then B perfectly simulates the view of A as in Corollary 3.14.14. This means there must exist some S such that if B runs A using this S using k1 with probability at least at least ǫ(λ) − negl(L) over the choice of k0, H, or k0. B now runs AH′′′.1 (k0||k1), and outputs. Whatever A outputs A, and outputs are the outputs of this output. If the proof of min-entropy is secure against uniform or non-uniform oracle-dependent adversaries, then so </p>
<p class="text"> In this section, they review basic deﬁnitions and facts on error correcting codes. Then, they show that such a code exists based on known results. A code of length n over an alphabet is a subset C ⊆ Σn. C is a folded linear code [Kra03, GR08] if its alphabet is Σ = Fmq for some prime power q and a positive integer m and C is C(m) for some linear code C and m. </p>
<p class="text"> The following lemma claims the existence of codes that are suitable for the purpose. Lemma 4.1 says that a code C ⊆ Σn is (ζ, ℓL) list recoverable if for any subsets Si. The lemma is not needed for the construction of a proof of quantumness given in Section 6.1. It is used only in the separation of one-way functions given in the section of Section 7.1.2. </p>
<p class="text"> They give a construction of codes that satisfy the properties stated in Lemma 4.2. A generalized Reed-Solomon code GRSFq,γ,k,v is a linear code over Fq that has length N = q − 1 and rank k + 1. They prove that the list decoding algorithm returns a unique result when the error comes from the distribution Dn. The proof of Lemma.2 is given in Section 4.3.4.1.1.<br/> The rank of (generalized) Reed-Solomon codes is the degree parameter k plus one. The lemma is based on Rudra’s PhD thesis [Rud07]. The same result is also presented in the journal version of [GR08], but note that there is a notational diﬁnition in the deﬀerence of list recovery. The result is the same result as that of GR08, Rud07, but they remark that the roles of n and N are swapped. </p>
<p class="text"> They show that folded Reed-Solomon codes satisfy the requirements of Lemma 4.2 if they set parameters appropriately. They set Cλ := RS(m)ophobicFq,γ,k, and |Cλ| = qk+1 ≥ 2n+λ. They prove that {Cλ}λ∉N satisﬁes the requirement s ≤ m in Lemma4.2.3. They also prove that they only have to prove that the requirement is satis ﬁed for suﬃciently large λ. </p>
<p class="text"> This is satisﬁed for suﬃciently large s, since they assume k = αNand ζ < 1 − α. The LHS of Equation (11) is O(λc′′) and the RHS is (ζ, ℓ, L)-list recoverable. This means that Item 1 of Lemma 4.2 has been proved. Since C = RS(m) is a folded Reed-Solomon code, its dual C⊥ is GRS(m), GRSFq,γ,N−k−2,v for some v.<br/> Chernoﬀ bound (Lemma 2.4) gives the deﬁnition of D and n = n = Θ(λ), Cherno-bound (Cherno) bound) gives Prenghrereghrreghreghn (Prenghrghre) and n) Dn is a distribution over Σn, but its sample can be interpreted as an element of FN (Fn) in the canonical </p>
<p class="text"> When Se = S∗, it is clear that they have hw(e) ≤ (1/2 + ǫ)N since |S∗|. The distribution of e is a direct product of copies of the uniform distribution over Fm.q. Since y ̸= 0 and degree d non-zero, polynomials have at least d roots, y can take 0 on at most d indices. They have a formula for some codeword of C⊥ is determined by values on d + 1 indices.<br/> Equation (18) and (20) together with Q = Ω(λ) and 1.2 − 3(1 − α) − 5 5ǫ > 0.09. Since 5/6 < α < 1, they can choose 0 < ǫ < 0.09 in such a way that 1.-3(1−α)−55 = 0. Equation (13) holds that the probabilities are the same noting that e. does not take 0 on any index and |. ¯S∗| > d + 2ǫN by the parameter choices. </p>
<p class="text"> There does not exist a codeword x such that hw(x) = n − j. This is because the corresponding polynomial f to x has at least mj ≥ k + 1 roots, which means that x = 0 since the degree of f is at most k. The case of j ≤ ⌉ < j < n is proven below. The lemma is inspired by the quantum step of Regev’s reduction from LWE to worst-case lattice problems. </p>
<p class="text"> Equations (21) and (22) immediately imply the following inequalities. Since BAD is the complement of GOOD, the above imply the above. They have a construction of proofs of quantumness in the QROM, which is the main result of this paper. Theorem 6.1.1: There exists a keyless proof of QROM with soundness against oracle-dependent adversaries. They also give the con-revelation theorem (Equation (4) in Lemma 2.3) for the sixth line. </p>
<p class="text"> By Theorem 3.8, they immediately obtain the following corollary. There exists a keyed proof of quantumness in the QROM with soundness against non-uniform oracle-dependent adversaries. They use notations deﬁned in Lemma 4.2 (e.g., m, m, ζ, ℓ, L etc). Let H : Σ → {0, 1}n be a random oracle with the domain {0-1}∗.16 For i ∈ [n], let Hi : be a function that on input x outputs the i-th bit of H(x) </p>
<p class="text"> The probability that Prove aborts is negligible. They prove the correctness assuming that a subset of H is uniformly chosen from a subset instead of from a set of functions deﬁned in Lemma 5.1. They show that the success probability of Prove failing to generate |φi⟩ in each trial to generate a 'prove' Prove' is negligible. They also prove that for an overwhelming fraction of H, there is a subset GOOD ⊆ Σn × and they have Prove. The following claim: The claim is true for using Lemma 6.3. </p>
<p class="text"> They use the notations deﬁned in the proof of Lemma 6.3 above. They prove Claim 6.4 later. The result is that an honestly generated proof π passes the veri﬉cation with a probability 1 − negl(λ) This means that an honest generated proof of correctness passes the test with the probability 1-1. They complete the proof by using Claim 6.4.1 and 6.5.4. They prove that an overwhelming fraction of H (H) and H (A) can be found in the same way. </p>
<p class="text"> They should prove that values of Equations (27) and (28) are negligible for an overwhelming fraction of H ∈ apologeticH. By a standard averaging argument, it suﬃces to prove that their expected values arenegligible, i.e.,. They prove that the distributions of H and H are identical when Hi and H ◦ π(resp. H) and H (H) are identical. Then, they prove Equations. </p>
<p class="text"> Equation (32) is proven as follows as follows. all z ∈ Σ. Equation Dn(e) holds that. all ei ∈. where D(·) is the probability density function of the distribution D as deﬁned in. 2 of Lemma 4.2. For any e = (e1,..., en) and H, since they have. a function B :. Σn → C so that ˆB satis. the following claims. </p>
<p class="text"> Claim 6.7 follows from the above equation and Parceval’s equality (Lemma 2.1) in the third equality. For any z, it holds that EH.H. entails that for any z z0, z1.1, they have the same result as the convolution theorem (Equation (6),) in the ﬁrst equality and convolution. They used ˆV (x) = 0 for x /∈ C⊥,e∉B,e B:x+e=z.apologetic; x/C:x:x/C; x:x </p>
<p class="text"> Theorem (30) is the constant of Lemma 4.2, where equality follows from the convolution theorem (Equation (5) in Lemma 2.3) They prove it below. They say that a codeword x = (x1,.., C is K-queried if there is a subset of a subset such that |I| = K, xi. For each i and j, let Sj be the set of elements that A′ ever queried to Hiby the point when it has just made the j-th query counting queries to any of H1, Hn.<br/> If x = (x1,.., xn) ∈ C is ⌈(1 − ζ)n⌉-queried at some point, they have xi ∈ SQ′i for all i, j. The number of codewords that ever become (ζ, ℓ, L)-list recoverable is at most L = 2 ˜O(λc′) as required in Item 1 of Lemma 4.2. </p>
<p class="text"> The Prove algorithm in Section 6 can be understood as an oracle-independent algorithm to transform fλ for the image 1n in the QROM. They give a construction of a family of functions that is one-way in the CROM but not one-ways in QROM as explained in Remark 4.2. They prove a stronger claim than that in Section 7.2 (Separation for One-way functions), they prove that such a function is not distributedally one way. The rest of the Lemma 6.1 follows from Lemmas 6.3 and 6.9.<br/> The proof of one-wayness in the CROM is similar to that of soundness of the proof of quan-tumness in Section 6.9. By a straightforward extension of Lemma 6.1n where they replace n with arbitrary y ∈ {0, 1}n, they obtain the claim. The claim is that n-y is not one way against oracle-independent adversaries in the QROM. The CROM has been proved to be sound </p>
<p class="text"> Claim 7.2: For any oracle-independent adversaries A that makes poly(λ) queries and y ∈ {0, 1}n, the distribution of y is almost independent of H. The one-wayness game does not immediately imply one wayness since in the game, y is chosen by sampling x and then setting y y instead of setting y f H.ophobicλ (x) instead of ﬁxing y independently of H.2. They prove this as follows where H and H′ are uniformly uniformly chosen. </p>
<p class="text"> They give a construction of a family of compressing functions that is collision-resistant in the CROM but not even one-way in the QROM. It is a generic construction based on proofs of quantumness. Theorem 7.1.6 (Separation for Collision-Resistant Hash Functions) follows from the version by Theorem 3.363636 (Theorem 3) and 7.2.3) of the keyed version by the keyless version below. They use Prx[hw(x) = n, n = Θ(λ), and |Cλ| ≥ 2n+λ for the ﬁnal line. </p>
<p class="text"> Theorem 7.1 gives one-way functions (OWFs) that are secure in the CROM but insecure in the QROM. Theorems 7.3 and 7.4 give separations between security in CROM and QROM for public key en-cryption (PKE) and digital signatures. They also show that any black-box construction of PRGs may remain secure even if the building block OWF is insecure. For example, there is no obvious attack against the PRGILL99 [HILL99] even with an OIFverter for the building of an OWF. </p>
<p class="text"> The Aaronson-Ambainis conjecture claims that for any algorithm A with a.quantum access to a random oracle, there is an algorithm B that. approximates the probability that. QROM security and CROM security for PRGs (against polynomial-query unbounded-time adversaries) are equivalent. They conclude that any single-bit output algorithm in the QROM can be simulated in the CROM with a polynomically blowup on the number of queries. </p>
<p class="text"> Theorems 3.6, 3.9 and 3.15, it suﬃces to prove the following. Theorem 8.1 is true, there exists keyless (resp. keyed) proofs of randomness in the QROM that has true randomness against uniform. non-uniform. oracle-dependentadversaries. They note that the number of B’s queries in the above conjecture depends on m unlike theirs due to this diﬀerence. They also remark that Aaronson and Ambainis [AA14] reduce the. above conjecture to another seemingly unrelated conjecture in Fourier analysis. </p>
<p class="text"> There is a polynomial h′(λ) such that if they replace the security.parameter with h’(λ), then it satisﬁes (2C(h(λ)+λ), 2−λ−2)-soundness. Then, they construct proofs of min-entropy (Prove, verify) as follows. They have to construct a classical adversary that breaks the soundness of the proof of quantumness. For making A into an almost deterministic attacker, the idea is to consider an algorithm Aj that outputs the smallest proof in the lexicographical order.<br/> Problem occurs if there are multiple π such that the probability that A outputs π is within ǫA ± 1/poly error. Poly means a polynomial in the number of repetition of A run by A′. The problem is that A′ cannot exactly compute the probabilities that A can run A many times to approximate the probabilities of A outputting π with a limited number of queries. A′ can do this to approximate probabilities up to a 1/Poly error </p>
<p class="text"> A′ is the lexigographically smallest valid proof that π is at least t for some randomly chosen threshold t. If they choose t from a large set and set the approximation error to be suﬃciently small, they can show that it isimpossible that there are multiple π such that the probability that A. outputs π. is within t±1/polyfor a large fraction of t by a simple counting argument. This resolves the above problem. They say that Approx(A, ǫ, ) succeeds if the event in the above event occurs. </p>
<p class="text"> Claim 8.6.23: For at least 1-2-fraction of H satisﬁes. (1) and i, if Approx(A, ǫA) succeeds, which occurs with.probability at least 4/5, then Ai outputs the smallest π in the lexicographical order that satis.(1) The number of queries by Ai is QAi = poly(λ, QA) since. ℓπ is the length of a proof.<br/> Conjec-protic-ture 8.1 ensures that there exists a deterministic classical algorithm Bi,j that makes poly(QAi.j, m, ǫ−1, δ−1) = poly(Poly)poly(λ, QA, ǫ+1), -δ+1; poly(λ) is deterministic. The algorithm is the result of an algorithm that makes classical queries and satis� </p>
