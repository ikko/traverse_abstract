<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Traverse Abstract</title>
    <link rel="stylesheet" href="/html/style.css">
</head>
  <a id="toggle" class="toggle-dark-mode button">☾</a>
  <script src="/html/script.js"></script>

<title>Traverse Abstract - Abstracting Noisy Robot Programs - Artificial Intelligence</title>
<body>
  <div  class="leftmargin">

     <h1> <a href="/">Traverse Abstract</a></h1>
     <p class="page-title"> Abstracting Noisy Robot Programs </p>
      <span class="card">
              <p class="page-theme"><a href="/theme/Artificial_Intelligence">Artificial Intelligence</a></p>
              <img class="media-object" src="/html/sums/abstract.png"/>
              <p class="media-body media-body-page article p1">Abstraction is a commonly used process to represent some low-level system by a more coarse speciﬁcation with the goal to omit unnecessary details while preserving important as-pects. They use a notion of bisimulation that allows us to abstract a detailed probabilistic basic action theory with noisy actuators and sensors. By doing so, they obtain abstract Golog pro-glygrams that omit unnecessary detail and which can be trans-fledgedlated back to a detailed program for actual execution. This opens-up the possibility of using deterministic reasoning methods (e.g., planning) on problems, and provides do-probabilistic descriptions that are more easily understandable and&lt;br/&gt; They present an abstraction framework forrobot programs with probabilistic belief: The situation calculus allows robots to control the behavior of robots. By using abstraction, they only need to update the low-level model and may keep the high-level program as is. They also show how this abstraction framework can be used to de-privilege a high level domain, where noisy actions are abstracted away and thus, no probabilism reasoning is necessary. They then conclude in Section 6.2: They provide a framework that can also be used in high-profile domains such as the situation calculus.</p>
              <img class="media-object" src="/html/sums/abstract.png"/>
              <p class="media-body media-body-page article  p2">The situation calculus, ES, and Golog programs are all deterministic and non-probabilistic, i.e., the executance action always results in a unique successor state. Abstraction (abstraction) is a mapping between ground and abstract formal system, such that the abstract repre-centricsentation preserves desirable properties while omitting unnecessary details to make it simpler to handle. Abstrraction has also been used to analyze causal models (Rubenstein et al. 2017; Banihashemi and Soutchanski 2022)&lt;br/&gt; The framework has been used to effectively synthe-size plan process controllers in a smart factory sce-nario (De Giacomo et al. 2019) It uses abstract and determistic ASP programs to determine a course of action, which are then translated to POMDPs for execu-probabilistic programs. In this paper, they build on the two approaches to obtain abstraction in a probabilistic and dynamic ﬁrst-order language with an unbounded domain. They use the logic DSG, which they will then use to deﬁne abstraction over noisy programs in noisy programs.&lt;br/&gt; Rk is rk, rk is Q, then rk becomes rk. Then rk and rk are rk can be rk into Q. Rk = rk; rk = Rk, Q, Q is Q. rk: rk + rk : rk. Rk: Rk; Rk + Rk= rk= Rk. B(α : r) is B(Rk) for rk</p>
              
                  <p class="media-body media-body-page article pn">To deﬁne the semantics of belief, they need to be able to summarize over uncountably many worlds, which they do as fol-apologeticlows. For example, BND(d, V, r) and there is no r′ &lt; r such that BND holds. for any U ⊆ V: NORM(D, U, V) iff. Such is the least set satisfying a certain type of formula: BND. The formula is the program transition semantics.
 The set of ﬁnal conﬁgurations Fe,w is the smallest set such a state that is possible in the current state. The semantics of the DSG program transition semantics and epis-temic states as de-denied above can be used to explain DSG formulas. For example, given an epistemic state, e, w, z, a world w, and a formula α, they de-de-deny the state of a formula as a result of a program transition. They only allow an in-state traces, as they do not include temporal formulas or in-night traces.
 A basic action theory (BAT) deﬁnes the precondi-tions and effects of all actions of the domain, as well as the initial state: The initial state is the state of a program. A program is a program over a program if it only mentions ﬂuents and actions from the program. The modality □ has lower syntactic precedence than the modality [·] has the highest priority. The semantics is well-de-nitioned, as De ﬁnition 14 only refers to static formulas with free variables, where α is static.</p>
              
                  <p class="media-body media-body-page article pn">A full example will be given in Section 5, but they already illustrate how they can model noisy actions. Consider the ac-iopsychtion grasp(o) that grasps an object o with a probability of 0.9 and fails to do so (and has no effect) with a probabilty of.1.9. The corresponding behaviors may look as follows:. (a) (a), (b), (c) (b) (c), (g) (e) (f) is a Golog program over the low-level BAT with free variables among ⃗x) The function m is a re-imagination mapping from a theory to a
 They say that (wh, wh, zh) is objectively m-isomorphic to (wl, zl) They establish a bisimulation for each of those pairs. For every high-level primitive action a, if eh, wh |=.poss(a), then there is z′ourceliopiopl, zi.iopl; for every high level primitive action there is a.zz: (eh, wh) and (el, wl) if (eh) is a (e) or (el) If (wh) is an (e), wl, l, l) or l, i, i: i: (e
 They say that (eh, wh) is bisimilar to (el, wl) relative to re-problems mapping m, written (eh) ∼m (el) If there exists a deﬁnite m-bisimulation relation B be tween (wh) and (el), it implies (wh, zh) is (w′.), which is (h, wh), which is a (h) with dl(w′,)) &gt; 0 and w′-griegel |= exec(z′.), w′.-grievl, w′.grievel, z′-egel,</p>
              
                  <p class="media-body media-body-page article pn">The general idea of bisimulation is that two states are not necessarily identical if they have the same local properties (i.e., they are) and each reachable state from the ﬁrst state has a corresponding reachable one from the second state. As usual in bisimulations, they also require that if they follow a high-level transition of the system, there is a corresponding low level transition (and vice versa) Here, properties 1, 2, and 3 refer to static properties of (wh, zh) and (wl, zl)
 Using the partition P = Sl/, they can directly take the union of both sides into account. Theoretically, if (eh, wh) is bisim-laden to (el, wl), then (e) and (e), wl) induce the same.traces of a program. If z′ is an arbitrary program, then there is z′.h, zi.β, and therefore (i.h) is an arbitrarily arbitrary program. Theoretic.probability of. the probability of. a program’s existence is the same as the. probability of all the. corresponding Si.
 Theorem 1 shows that for any form that occurs in δ, they can show that it is satisﬁed by (eh, wh, zh) iff it is (el, wl, zl) or (poss(a) If z′phthalphthalphthalmologist) is B.2. If they have a form of a form that is B., they have the form of B.glyglyphanic, B.ly.ly. They also have the formula for B.ylphanica, Bylvylvicrophanic.lyvicic.ylvich.lyl.lyf.ly</p>
              
                  <p class="media-body media-body-page article pn">Theorem 1 would not hold if δ contained interleaved concurrency. For a high-level program such as a1.h∥a2.h, the only valid traces would be a 1-1-2-1 program. On the other hand, with m(a1) = a1, a1; a2, a2; a3; a4; a5:7; a6:7: 7:7.7:7/7: They express the agent’s knowledge about the initial situation and study entail entailment.
 The strongest notion of abstraction is the combination of sound and complete abstraction: &#34;Sound and Complete Abstraction&#34; They say that a sound abstraction ensures that any entailment of the high-level BAT Σh is consistent with the low-level ABΣl. They present a full example of abstraction in a sim-ple robotics scenario with noisy actions inspired from the works of Belle and Lakemeyer in a scenario inspired by the work of the two authors of L.A. and L.M. Lakemeyer.</p>
              
                  <p class="media-body media-body-page article pn">They start with the low-level BAT Σmove: The robot is capable of doing a single noisy move(x, y) where x is the distance it intends to move and y is the amount of movement that actually happens. With probability p = 0.6, the robot does the intended movement, and with probability p.6, it either moves one step too far (i.e., y − x = 1) or one step. too close (yx = −1), with error of ±1.2. They abstract the exact distance to the wall Loc(x) to three regions At(infront, At(near), At(far) and At
 The re-mement mapping m maps the high-level ﬂuent ﬁuent At and the high level action goto to the corresponding low-level formula and program: &#34;At(l)&#34;) &#34;Goto&#34; moves to one of the three regions (without noise) The robot is always always able to reach the goal region with certainty. To do so, it interleaves single-step-move actions (move(1) or move(−1) with sonar actions. After the second move, the robot is at Loc(2)</p>
              
          <a class="media" href="https://arxiv.org/abs/2204.03536" target="_blank">
            <h2 class="paper">Paper</h2>
          </a>
      </span>
  </div>
</body>

</html>